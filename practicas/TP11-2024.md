# TP 11 - Estructuras lineales

## Forma de entrega

- No olviden completar la plantilla con sus datos y agregar la descripción de cada función.
  Aunque `main` puede no tener este comentario, no está de más registrar que es lo que el
  `Scanner` recibe.
- Siempre que sea posible, los mensajes de commit deben ser descriptivos.
- La entrada y salida debe estar separada de la función que cumple la consigna, salvo que la
  consigna lo pida.
- No olviden la utilización de auto-formato, las herramientas de corrección le prestan atención
  a este tema.
- Puede ser necesario completar, cambiar y ajustar la documentación de las funciones pedidas.
- Es posible hacer cambios en la forma de las funciones a implementar, pero para esto,
  indiquenló explicitamente en el comentario de documentación.
- No olviden crear Tests.

Finalmente, pueden usar los
atajos [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP4%20-%20)
para crear preguntas sobre los enunciados individuales, si es posible, no fusionen las preguntas,
así es más fácil que sus compañeros encuentren las respuestas, y pueden otorgarles más puntos a
quienes responden.

## Listas enlazadas

## Interfaz Secuencias

```java
/**
 * La interfaz Secuenciable define los métodos para manipular y acceder a los elementos de
 * una secuencia ordenada de elementos.
 *
 *
 * @param <T> El tipo de elementos contenidos en el arreglo.
 */
public interface Secuenciable<T> {
    /**
     * Agrega un nuevo elemento a la secuencia.
     *
     * @param elemento el nuevo elemento que será insertado en la posición indicada.
     * @param posicion es la ubicacion que ocupará el nuevo elemento.
     */
    void insertar(T elemento, int posicion);

    /**
     * Elimina el elemento en la posición indicada.
     *
     * @param posicion del elemento que se desea eliminar.
     * @throws PosicionFueraDeLugar si la posición especificada está fuera de los límites de la estructura.
     */
    void remover(int posicion);

    /**
     * Modifica el elemento en la posición especificada del arreglo.
     *
     * @param elemento El nuevo elemento que reemplazará el existente en la posición especificada.
     * @param posicion La posición del elemento que será modificado.
     * @throws PosicionFueraDeLugar si la posición especificada está fuera de los límites de la estructura.
     */
    void modificar(T elemento, int posicion);

    /**
     * Obtiene el elemento en la posición especificada del arreglo.
     *
     * @param posicion del elemento que se desea obtener.
     * @return El elemento en la posición especificada.
     * @throws PosicionFueraDeLugar si la posición especificada está fuera de los límites de la estructura.
     */
    T obtener(int posicion);

    /**
     * Retorna el número de elementos en la secuencia.
     *
     * @return La cantidad de elementos en la secuencia.
     */
    int largo();

    /**
     * Retorna una representación en forma de cadena de los elementos contenidos.
     * <p>
     * De forma [1, 2, 3, 4, 5]
     * @return Una cadena que representa los elementos del arreglo.
     */
    @Override
    String toString();
}
```

### Implementación `ListaEnlazada`: [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Lista%20enlazada)

La clase que implemente esta interfaz debe:

1. Implementar `Iterable`
2. Implementar `toString`.
3. Un constructor que reciba un `Iterable`
4. Las operaciones que manipulen valores deben rechazar valores `null`.
5. Los Nodos deben ser una clase interna.

#### Opcionales [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Lista%20enlazada%20-%20opcionales)

1. Crear un decorador que transforme la lista en una de solo lectura.
2. Crear un decorador, que permita a un visitante efectuar operaciones.
    - Creen visitantes para `T` de tipo `Number` para sumar y promediar el contenido.

### Implementación `ListaOrdenable` [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Lista%20Ordenada)

Implementen la siguiente interfaz, en una clase que también implemente
la interfaz `Secuenciable` e `Iterable` como una Lista Enlazada.

```java
/**
 * La interfaz Ordenable define el método, y las garantías para que 
 * algo pueda ser ordenable.
 *
 * @param <T> El tipo de elementos contenidos en el arreglo, 
 *           los mismos deben implementar `Comparable`.
 */
public interface Ordenable<T extends Comparable<T>> {

    /**
     * Este método ordena el contenido de menor a mayor.
     * {@link Comparable}.
     */
    void ordenar();

    /**
     * Este método permite ordenar siguiendo un criterio especifico.
     * {@link Comparator}.
     * @param criterio la forma de comparar los T contenidos.
     */
    void ordenar(Comparator<T> criterio);

}
```

#### Opcional [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Lista%20ordenable%20-%20opcional)

Hacer que el algoritmo de ordenamiento pueda ser elegido en tiempo de ejecución.

## Pila / Stack [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Stack)

Implementen una Pila dinámica.

```java
/**
 * Representa una secuencia 'último en entrar, primero en salir' (LIFO).
 *
 * @param <T> es el tipo de elementos que contendrá la estructura.
 */
public interface Stack<T> {
    /**
     * Agrega un elemento a la pila.
     * @param elemento a agregar
     */
    void push(T elemento);

    /**
     * Toma un elemento de la pila.
     * @return el elemento del tope de la pila.
     * @throws PilaVaciaException cuando no hay que ver.
     */
    T pop();

    /**
     * Devuelve el valor del tope de la pila sin sacarlo.
     * @return el elemento del tope de la pila.
     * @throws PilaVaciaException cuando no hay que ver.
     */
    T top();

    /**
     * Indica si la pila contiene elementos.
     * @return {@code true} si la misma esta sin elementos.
     */
    boolean isEmpty();
}
```

### Implementación `PilaDinamica`:

La clase que implemente esta interfaz debe:

1. Implementar `Iterable`
2. Un constructor que reciba un `Iterable`
3. `push` debe rechazar valores `null`

### Usos de `PilaDinamica`

#### Invertible [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Stack%20invertible)

Crear un nuevo tipo de `ListaEnlazada` para implementar la interfaz `Invertible`,
en el cual, se invertirá el orden de la lista sin crear un arreglo intermedio o
nuevos nodos.

```java
/**
 * Esta interfaz define el comportamiento de objetos que pueden ser invertidos.
 *
 * <p>Un objeto invertible es aquel que puede modificar su estado interno para 
 * representar una versión invertida de sí mismo.</p>
 *
 * @param <T> El tipo de objeto que implementa esta interfaz.
 */
public interface Invertible<T> {
    /**
     * Invierte el estado interno del objeto.
     *
     * <p>Después de llamar a este método, el objeto debe representar su versión 
     * invertida.</p>
     */
    void invertir();
}
```

#### Esta balanceado? [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP11%20-%20Stack-balanceado)

Creen una función que permita saber si una combinación de corchetes es correcta o no.

Creen la clase `BalanceadoApp` conteniendo un `main` que utilizando la función implementada, 
permita saber si los pares de `[]` en una cadena ingresada por el usuario se encuentran balanceados o no.

Esto es, para cada símbolo de apertura, hay uno de cierre.

**Ejemplos**:

```
[] esta balanceado
[][] esta balanceado
[[]] esta balanceado
[][[][[]]] esta balanceado
```

**Contraejemplos:**

Importante; la indicación de qué carácter impide que la cadena esté balanceado es parte
de la consigna Opcional 1.

Este cierra antes de abrir:

```
[]][][[[]]] no esta balanceado
--^
```

Este abre sin cerrar:

```
[[]][
----^
```

#### Opcional 1: Indicación

Crear una función que indique el número de carácter que impide que la cadena quede balanceada.

Utilizar esta función en un main que muestre el carácter, como en los ejemplos de la consigna.

#### Opcional 2: Balanceado y estructurado

Creen una nueva función que verifique si una cadena conteniendo `()`, `[]` y `{}` se encuentran
además de balanceados, correctamente estructurados.

Esto es que los caracteres diferentes no pueden 'salir' de otro, por ejemplo
`([)]` esta balanceado, pero no es correcto, los corchetes están mezclados con los parentesis.

    
