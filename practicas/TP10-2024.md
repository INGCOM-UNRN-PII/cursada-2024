# TP 10 - Arreglos V - Patrones de dise침o

## Forma de entrega

- No olviden completar la plantilla con sus datos y agregar la descripci칩n de cada funci칩n.
  Aunque `main` puede no tener este comentario, no est치 de m치s registrar que es lo que el
  `Scanner` recibe.
- Siempre que sea posible, los mensajes de commit deben ser descriptivos.
- Implementen un main que haga un uso de las funciones implementadas, pueden utilizar un `Scanner`.
- La entrada y salida debe estar separada de la funci칩n que cumple la consigna, salvo que la consigna lo pida.
- No olviden la utilizaci칩n de auto-formato, las herramientas de correcci칩n le prestan atenci칩n
  a este tema.
- Puede ser necesario completar, cambiar y ajustar la documentaci칩n de las funciones pedidas.
- Es posible hacer cambios en la forma de las funciones a implementar, pero para esto, indiquenl칩 explicitamente
  en el comentario de documentaci칩n.
- No olviden crear Tests.

Finalmente, pueden usar los atajos [SOS - 游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP4%20-%20)
para crear preguntas sobre los enunciados individuales, si es posible, no fusionen las preguntas, as칤 es m치s f치cil que
sus compa침eros encuentren las respuestas, y pueden otorgarles mas puntos a quienes responden.

## Consigna general

La idea es extender el `ArregloGenerico` base del TP9 con nuevas capacidades.

La organizaci칩n de las clases debe ser:

1. La ra칤z debe ser `ar.unrn.patrones`
2. Creen un paquete por patr칩n.
3. Las excepciones deben ser propias y estar alojadas dentro del paquete `ar.unrn.patrones.excepciones`

## `ArregloBase` [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloBase)

La implementaci칩n base de este arreglo, es la del TP9, y tambi칠n la base para todos los dem치s.
Quiz치s tengan que agregar alg칰n constructor. Pero la idea es que reciba pocos cambios.

Como esta clase es utilizada en los otros ejercicios, llamenl치 `ArregloBase.`

Como esta clase es la base de todas las dem치s, d칠jenla en la ra칤z de paquetes, es necesario tambi칠n
que este como interfaz para algunos de los patrones.

```java
/**
 * La interfaz Arreglo define los m칠todos para manipular y acceder a los elementos de un arreglo,
 * as칤 como para iterar sobre ellos.
 *
 * @param <T> El tipo de elementos contenidos en el arreglo.
 */
public interface Arreglo<T> extends Iterable<T> {

    /**
     * Modifica el elemento en la posici칩n especificada del arreglo.
     *
     * @param elemento El nuevo elemento que reemplazar치 el existente en la posici칩n especificada.
     * @param posicion La posici칩n del elemento que ser치 modificado.
     * @throws PosicionFueraDelArreglo si la posici칩n especificada est치 fuera del rango.
     */
    void modificar(T elemento, int posicion);

    /**
     * Obtiene el elemento en la posici칩n especificada del arreglo.
     *
     * @param posicion La posici칩n del elemento que se desea obtener.
     * @return El elemento en la posici칩n especificada.
     * @throws PosicionFueraDelArreglo si la posici칩n especificada est치 fuera del rango.
     */
    T obtener(int posicion);

    /**
     * Retorna el n칰mero de elementos en el arreglo.
     *
     * @return La cantidad de elementos en el arreglo.
     */
    int largo();

    /**
     * Retorna un iterador sobre los elementos en el arreglo.
     *
     * @return Un nuevo iterador sobre los elementos del arreglo.
     */
    @Override
    Iterator<T> iterator();

    /**
     * Retorna una representaci칩n en forma de cadena de los elementos en el arreglo.
     * <p>
     * De forma [1, 2, 3, 4, 5]
     * @return Una cadena que representa los elementos del arreglo.
     */
    @Override
    String toString();
}
```

Constructores:

- Constructor por copia de otro `Arreglo`
- Constructor por copia de un arreglo tradicional (`[]`).
- Constructor con indicaci칩n del tama침o.

## Decorator [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloDecorado)

Es recomendable crear una clase abstracta `ArregloDecorable` implementando la interfaz,
para que al momento de completar la decoraci칩n, tengamos c칩digo con el cual reutilizar
para los cambios.

### Decoradores a implementar

1. Registro de operaciones, implementar un decorador que env칤e por consola que cambio sufri칩 el arreglo decorado.
2. Arreglo de solo lectura, implementar un arreglo decorado` que impida cambios en las instancias de
   valores que contenga.

## Singleton [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloCompartido)

Crear un arreglo derivado de `ArregloBase`, llamado `ArregloCompartido`, aplicando el patr칩n Singleton.

## Estrategia (Strategy) [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloOrdenable)

Crear una clase de `ArregloBase`, llamada `ArregloOrdenable` que sea ordenable.
Pero ojo, este no es como el que se mantiene ordenado del TP9. La idea de este nuevo arreglo, es
que podamos cambiar el algoritmo de ordenamiento.

```java
public interface Ordenador<T extends Comparable<T>> {
    void ordenar(Arreglo<T> arreglo);
}
```

Y la llamada al algoritmo quedar칤a como, observen que, a pesar de llamarse igual, no reciben los mismos
argumentos, la implementaci칩n ser칤a algo como:

```java
public interface ArregloOrdenable<T extends Comparable<T>> extends Arreglo<T> {
    void ordenar();
}
```
Una implementaci칩n de ordenar, puede ser tan simple como:
```java
void ordenar() {
    this.estrategia.ordenar(this);
}
```

### Algoritmos de ordenamiento

Implementen por lo menos dos algoritmos aparte de Burbuja.

### Opcional

Para aumentar a칰n m치s la flexibilidad del arreglo, modifiquen la interfaz para que esta pueda recibir al ordenar
un `Comparator` compatible,

## Observer [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloObservable)

La idea de este patron, es la generaci칩n de eventos, y responder ante ellos.
Crear un tipo de `Arreglo` llamado `ArregloObservable` en el que podamos subscribirnos a los
cambios en su contenido.

### Observable

```java
/**
 * La interfaz Observer define el m칠todo para recibir notificaciones de cambios
 * en el sujeto observable.
 *
 * @param <T> El tipo de elementos que ser치n observados.
 */
public interface Observer<T> {
    /**
     * M칠todo llamado para notificar al observador de un cambio en el sujeto observable.
     *
     * @param observable El sujeto observable que notifica el cambio.
     * @param indice El 칤ndice del elemento que ha cambiado.
     */
    void actualizar(ArregloObservable<T> observable, int indice);
}
```

### Observable

```java
/**
 * La interfaz Observable define los m칠todos para gestionar observadores y
 * notificarles de cambios.
 *
 * @param <T> El tipo de elementos que ser치n observados.
 */
public interface Observable<T> extends Arreglo<T> {
    /**
     * A침ade un observador a la lista de observadores.
     *
     * @param observador El observador que ser치 a침adido.
     */
    void addObserver(Observer<T> observador);

    /**
     * Elimina un observador de la lista de observadores.
     *
     * @param observador El observador que ser치 eliminado.
     */
    void removeObserver(Observer<T> observador);

    /**
     * Notifica a todos los observadores sobre un cambio en el sujeto observable.
     *
     * @param indice El 칤ndice del elemento que ha cambiado, o cualquier otro 
     *               dato relevante para los observadores.
     */
    void notificarObservadores(int indice);
}

```

### Observadores a implementar

1. Uno que muestre por pantalla el cambio hecho (s칤, con `print`).
2. Uno que replique el mismo cambio en un arreglo normal.

### Opcional

Hacer que la funcionalidad de `Observer` se conecte empleando el patr칩n `Decorator`.

## Visitor [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloVisitable)

Crear un tipo de Arreglo que implemente `Visitable`;

```java
/**
 * La interfaz Visitable define el m칠todo para aceptar un visitante.
 *
 * @param <T> El tipo de elementos que ser치n visitados.
 */
public interface Visitable<T> {
    /**
     * Acepta un visitante que realizar치 alguna operaci칩n en los elementos visitables.
     *
     * @param visitor El visitante que realizar치 la operaci칩n.
     */
    void visitar(Visitor<T> visitor);
}
```

Y luego implementar los `Visitor`es siguiendo la siguiente interfaz.

```java
/**
 * La interfaz Visitor define el m칠todo para visitar elementos.
 *
 * @param <T> El tipo de elementos que ser치n visitados.
 */
public interface Visitor<T> {
    /**
     * Realiza una operaci칩n en el elemento visitado.
     *
     * @param elemento El elemento que ser치 visitado.
     */
    void visita(T elemento);
}
```

Crear visitantes para

1. Un visitor para sumar los n칰meros `Integer` contenidos en el `ArregloVisitable`
2. Un visitor para construir una cadena con el contenido del `ArregloVisitable`.

## Informe m치s patrones [游](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20Informe)

Sugieran y documenten la aplicaci칩n de otros patrones de dise침o a `Arreglos`, no es necesario
documentarlo, pero si describan para que pueda ser util. Por lo menos uno diferente a los que
ya est치n en la pr치ctica, tengan en cuenta que los patrones pueden ser aplicados de otra forma.

Dejen un informe llamado `patrones-usuario.md` en la ra칤z del repositorio, luego este informe ser치
luego compartido en el repositorio cursada-2024.
