# TP 10 - Arreglos V - Patrones de diseño

## Forma de entrega

- No olviden completar la plantilla con sus datos y agregar la descripción de cada función.
  Aunque `main` puede no tener este comentario, no está de más registrar que es lo que el
  `Scanner` recibe.
- Siempre que sea posible, los mensajes de commit deben ser descriptivos.
- Implementen un main que haga un uso de las funciones implementadas, pueden utilizar un `Scanner`.
- La entrada y salida debe estar separada de la función que cumple la consigna, salvo que la consigna lo pida.
- No olviden la utilización de auto-formato, las herramientas de corrección le prestan atención
  a este tema.
- Puede ser necesario completar, cambiar y ajustar la documentación de las funciones pedidas.
- Es posible hacer cambios en la forma de las funciones a implementar, pero para esto, indiquenló explicitamente
  en el comentario de documentación.
- No olviden crear Tests.

Finalmente, pueden usar los atajos [SOS - 🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP4%20-%20)
para crear preguntas sobre los enunciados individuales, si es posible, no fusionen las preguntas, así es más fácil que
sus compañeros encuentren las respuestas, y pueden otorgarles mas puntos a quienes responden.

## Consigna general

La idea es extender el `ArregloGenerico` base del TP9 con nuevas capacidades.

La organización de las clases debe ser:

1. La raíz debe ser `ar.unrn.patrones`
2. Creen un paquete por patrón.
3. Las excepciones deben ser propias y estar alojadas dentro del paquete `ar.unrn.patrones.excepciones`

## `ArregloBase` [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloBase)

La implementación base de este arreglo, es la del TP9, y también la base para todos los demás.
Quizás tengan que agregar algún constructor. Pero la idea es que reciba pocos cambios.

Como esta clase es utilizada en los otros ejercicios, llamenlá `ArregloBase.`

Como esta clase es la base de todas las demás, déjenla en la raíz de paquetes, es necesario también
que este como interfaz para algunos de los patrones.

```java
/**
 * La interfaz Arreglo define los métodos para manipular y acceder a los elementos de un arreglo,
 * así como para iterar sobre ellos.
 *
 * @param <T> El tipo de elementos contenidos en el arreglo.
 */
public interface Arreglo<T> extends Iterable<T> {

    /**
     * Modifica el elemento en la posición especificada del arreglo.
     *
     * @param elemento El nuevo elemento que reemplazará el existente en la posición especificada.
     * @param posicion La posición del elemento que será modificado.
     * @throws PosicionFueraDelArreglo si la posición especificada está fuera del rango.
     */
    void modificar(T elemento, int posicion);

    /**
     * Obtiene el elemento en la posición especificada del arreglo.
     *
     * @param posicion La posición del elemento que se desea obtener.
     * @return El elemento en la posición especificada.
     * @throws PosicionFueraDelArreglo si la posición especificada está fuera del rango.
     */
    T obtener(int posicion);

    /**
     * Retorna el número de elementos en el arreglo.
     *
     * @return La cantidad de elementos en el arreglo.
     */
    int largo();

    /**
     * Retorna un iterador sobre los elementos en el arreglo.
     *
     * @return Un nuevo iterador sobre los elementos del arreglo.
     */
    @Override
    Iterator<T> iterator();

    /**
     * Retorna una representación en forma de cadena de los elementos en el arreglo.
     * <p>
     * De forma [1, 2, 3, 4, 5]
     * @return Una cadena que representa los elementos del arreglo.
     */
    @Override
    String toString();
}
```

Constructores:

- Constructor por copia de otro `Arreglo`
- Constructor por copia de un arreglo tradicional (`[]`).
- Constructor con indicación del tamaño.

## Decorator [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloDecorado)

Es recomendable crear una clase abstracta `ArregloDecorable` implementando la interfaz,
para que al momento de completar la decoración, tengamos código con el cual reutilizar
para los cambios.

### Decoradores a implementar

1. Registro de operaciones, implementar un decorador que envíe por consola que cambio sufrió el arreglo decorado.
2. Arreglo de solo lectura, implementar un arreglo decorado` que impida cambios en las instancias de
   valores que contenga.

## Singleton [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloCompartido)

Crear un arreglo derivado de `ArregloBase`, llamado `ArregloCompartido`, aplicando el patrón Singleton.

## Estrategia (Strategy) [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloOrdenable)

Crear una clase de `ArregloBase`, llamada `ArregloOrdenable` que sea ordenable.
Pero ojo, este no es como el que se mantiene ordenado del TP9. La idea de este nuevo arreglo, es
que podamos cambiar el algoritmo de ordenamiento.

```java
public interface Ordenador<T extends Comparable<T>> {
    void ordenar(Arreglo<T> arreglo);
}
```

Y la llamada al algoritmo quedaría como, observen que, a pesar de llamarse igual, no reciben los mismos
argumentos, la implementación sería algo como:

```java
public interface ArregloOrdenable<T extends Comparable<T>> extends Arreglo<T> {
    void ordenar();
}
```
Una implementación de ordenar, puede ser tan simple como:
```java
void ordenar() {
    this.estrategia.ordenar(this);
}
```

### Algoritmos de ordenamiento

Implementen por lo menos dos algoritmos aparte de Burbuja.

### Opcional

Para aumentar aún más la flexibilidad del arreglo, modifiquen la interfaz para que esta pueda recibir al ordenar
un `Comparator` compatible,

## Observer [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloObservable)

La idea de este patron, es la generación de eventos, y responder ante ellos.
Crear un tipo de `Arreglo` llamado `ArregloObservable` en el que podamos subscribirnos a los
cambios en su contenido.

### Observable

```java
/**
 * La interfaz Observer define el método para recibir notificaciones de cambios
 * en el sujeto observable.
 *
 * @param <T> El tipo de elementos que serán observados.
 */
public interface Observer<T> {
    /**
     * Método llamado para notificar al observador de un cambio en el sujeto observable.
     *
     * @param observable El sujeto observable que notifica el cambio.
     * @param indice El índice del elemento que ha cambiado.
     */
    void actualizar(ArregloObservable<T> observable, int indice);
}
```

### Observable

```java
/**
 * La interfaz Observable define los métodos para gestionar observadores y
 * notificarles de cambios.
 *
 * @param <T> El tipo de elementos que serán observados.
 */
public interface Observable<T> extends Arreglo<T> {
    /**
     * Añade un observador a la lista de observadores.
     *
     * @param observador El observador que será añadido.
     */
    void addObserver(Observer<T> observador);

    /**
     * Elimina un observador de la lista de observadores.
     *
     * @param observador El observador que será eliminado.
     */
    void removeObserver(Observer<T> observador);

    /**
     * Notifica a todos los observadores sobre un cambio en el sujeto observable.
     *
     * @param indice El índice del elemento que ha cambiado, o cualquier otro 
     *               dato relevante para los observadores.
     */
    void notificarObservadores(int indice);
}

```

### Observadores a implementar

1. Uno que muestre por pantalla el cambio hecho (sí, con `print`).
2. Uno que replique el mismo cambio en un arreglo normal.

### Opcional

Hacer que la funcionalidad de `Observer` se conecte empleando el patrón `Decorator`.

## Visitor [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20ArregloVisitable)

Crear un tipo de Arreglo que implemente `Visitable`;

```java
/**
 * La interfaz Visitable define el método para aceptar un visitante.
 *
 * @param <T> El tipo de elementos que serán visitados.
 */
public interface Visitable<T> {
    /**
     * Acepta un visitante que realizará alguna operación en los elementos visitables.
     *
     * @param visitor El visitante que realizará la operación.
     */
    void visitar(Visitor<T> visitor);
}
```

Y luego implementar los `Visitor`es siguiendo la siguiente interfaz.

```java
/**
 * La interfaz Visitor define el método para visitar elementos.
 *
 * @param <T> El tipo de elementos que serán visitados.
 */
public interface Visitor<T> {
    /**
     * Realiza una operación en el elemento visitado.
     *
     * @param elemento El elemento que será visitado.
     */
    void visita(T elemento);
}
```

Crear visitantes para

1. Un visitor para sumar los números `Integer` contenidos en el `ArregloVisitable`
2. Un visitor para construir una cadena con el contenido del `ArregloVisitable`.

## Informe más patrones [🆘](https://github.com/orgs/INGCOM-UNRN-PII/discussions/new?category=preguntas-y-respuestas&title=TP10%20-%20Informe)

Sugieran y documenten la aplicación de otros patrones de diseño a `Arreglos`, no es necesario
documentarlo, pero si describan para que pueda ser util. Por lo menos uno diferente a los que
ya están en la práctica, tengan en cuenta que los patrones pueden ser aplicados de otra forma.

Dejen un informe llamado `patrones-usuario.md` en la raíz del repositorio, luego este informe será
luego compartido en el repositorio cursada-2024.
